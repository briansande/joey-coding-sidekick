# Roocode Extension API Documentation

This document provides a comprehensive overview of the Roocode Visual Studio Code extension's public API. It is intended for developers who want to build extensions that interact with Roocode.

## Accessing the API

To access the Roocode API, you first need to get a reference to the Roocode extension and then activate it. Once activated, the extension will return an API object that you can use to interact with Roocode.

```typescript
import * as vscode from 'vscode';
import { RooCodeAPI } from './types'; // Assuming you have access to the types from your extension

async function getRooCodeApi(): Promise<RooCodeAPI | undefined> {
    const rooCodeExtension = vscode.extensions.getExtension<RooCodeAPI>('RooVeterinaryInc.roo-cline');
    if (!rooCodeExtension) {
        console.error('Roocode extension not found.');
        return undefined;
    }

    try {
        const api = await rooCodeExtension.activate();
        return api;
    } catch (error) {
        console.error('Failed to activate Roocode extension:', error);
        return undefined;
    }
}
```

The returned API object is an instance of a class that implements `RooCodeAPI`, which is an `EventEmitter`. This means you can listen for events using the `.on()` method and send commands using the public methods.

## API Methods

The main API object exposes several methods to control Roocode tasks and configuration.

### Task Management

-   `startNewTask(options: { configuration: RooCodeSettings, text?: string, images?: string[], newTab?: boolean }): Promise<string>`: Starts a new Roocode task. Returns the `taskId` of the new task.
-   `sendMessage(message: string): Promise<void>`: Sends a message to the current task.
-   `pressPrimaryButton(): Promise<void>`: Simulates a click on the primary button in the Roocode webview.
-   `pressSecondaryButton(): Promise<void>`: Simulates a click on the secondary button in the Roocode webview.

## Events

You can listen to events emitted by the API to monitor the state of Roocode tasks.

```typescript
rooApi.on('taskStarted', (taskId) => {
    console.log(`Task ${taskId} has started.`);
});
```

### Task Lifecycle Events

-   `taskCreated: (taskId: string)`: Fired when a new task is created.
-   `taskStarted: (taskId:string)`: Fired when a task starts running.
-   `taskCompleted: (taskId: string, tokenUsage: TokenUsage, toolUsage: ToolUsage, options: { isSubtask: boolean })`: Fired when a task finishes.
-   `taskAborted: (taskId: string)`: Fired when a task is cancelled.
-   `taskFocused: (taskId: string)`: Fired when a task gains focus.
-   `taskUnfocused: (taskId: string)`: Fired when a task loses focus.
-   `taskActive: (taskId: string)`: Fired when a task becomes active.
-   `taskInteractive: (taskId: string)`: Fired when a task requires user interaction.
-   `taskResumable: (taskId: string)`: Fired when a task can be resumed.
-   `taskIdle: (taskId: string)`: Fired when a task is idle.

### Subtask Lifecycle Events

-   `taskPaused: (taskId: string)`: Fired when a subtask is paused.
-   `taskUnpaused: (taskId: string)`: Fired when a subtask is resumed.
-   `taskSpawned: (parentTaskId: string, childTaskId: string)`: Fired when a task creates a subtask.

### Task Execution Events

-   `message: (data: { taskId: string, action: 'created' | 'updated', message: ClineMessage })`: Fired when a new message is generated by a task.
-   `taskModeSwitched: (taskId: string, modeSlug: string)`: Fired when the mode of a task changes.
-   `taskAskResponded: (taskId: string)`: Fired when a user responds to an `ask` message.

### Analytics & Tooling Events

-   `taskToolFailed: (taskId: string, toolName: ToolName, error: string)`: Fired when a tool used by a task fails.
-   `taskTokenUsageUpdated: (taskId: string, usage: TokenUsage)`: Provides real-time updates on the token usage of a task.

## Tracking Tool Usage

You can determine if, when, and what tools are being used by listening to specific API events.

### Knowing *What* Tools Were Used (End of Task)

You can get a complete summary of all tools used during a task by listening for the `taskCompleted` event. The payload of this event includes a `toolUsage` object that details the number of attempts and failures for each tool.

```typescript
rooApi.on('taskCompleted', (taskId, tokenUsage, toolUsage) => {
    console.log(`Task ${taskId} completed. Tool Usage:`, toolUsage);
    // Example toolUsage: { "read_file": { "attempts": 2, "failures": 0 } }
});
```

### Knowing *When* a Tool Is Used (Real-time Failures)

While there is no real-time event for successful tool executions, you can be notified immediately when a tool fails. The `taskToolFailed` event provides the name of the tool that failed and the corresponding error message.

```typescript
rooApi.on('taskToolFailed', (taskId, toolName, error) => {
    console.error(`Task ${taskId}: Tool '${toolName}' failed with error: ${error}`);
});
```

## Data Structures

The API uses several data structures to pass information.

### `TokenUsage`

Provides information about the number of tokens used by a task.

```typescript
interface TokenUsage {
    totalTokensIn: number;
    totalTokensOut: number;
    totalCacheWrites?: number;
    totalCacheReads?: number;
    totalCost: number;
    contextTokens: number;
}
```

### `ToolUsage`

Provides information about the tools used by a task.

```typescript
type ToolUsage = Record<ToolName, {
    attempts: number;
    failures: number;
}>;
```

### `ToolName` (Agent-Facing Tools)

The following are tools the AI agent can request to use. Their usage is tracked in the `toolUsage` object of the `taskCompleted` event.

-   `execute_command`
-   `read_file`
-   `write_to_file`
-   `apply_diff`
-   `insert_content`
-   `search_and_replace`
-   `search_files`
-   `list_files`
-   `list_code_definition_names`
-   `browser_action`
-   `use_mcp_tool`
-   `access_mcp_resource`
-   `ask_followup_question`
-   `attempt_completion`
-   `switch_mode`
-   `new_task`
-   `fetch_instructions`
-   `codebase_search`
-   `update_todo_list`
-   `generate_image`

### Informational "Say" Tools

These are not tools the agent requests, but rather informational messages sent from the system to the UI to report that an action has occurred. Your tool-checking algorithm should look for the `tool` property within a `say` type `ClineMessage`.

-   `editedExistingFile`: A file that already existed has been modified.
-   `newFileCreated`: A new file has been created.
-   `appliedDiff`: A diff was successfully applied to a file.
-   `codebaseSearch`: A codebase search was performed.
-   `readFile`: A file was read.
-   `fetchInstructions`: Instructions were fetched.
-   `listFilesTopLevel`: A top-level file listing was performed.
-   `listFilesRecursive`: A recursive file listing was performed.
-   `listCodeDefinitionNames`: Code definitions were listed.
-   `searchFiles`: A file search was performed.
-   `switchMode`: The mode was switched.
-   `newTask`: A new task was created.
-   `finishTask`: The task was finished.
-   `searchAndReplace`: A search and replace operation was completed.
-   `insertContent`: Content was inserted into a file.
-   `generateImage`: An image generation process was initiated.
-   `imageGenerated`: An image has been successfully generated.


### `ClineMessage`

Represents a message in the Roocode chat.

```typescript
interface ClineMessage {
    ts: number;
    type: 'ask' | 'say';
    ask?: ClineAsk;
    say?: ClineSay;
    text?: string;
    images?: string[];
    partial?: boolean;
    reasoning?: string;
    // ... and other properties
}